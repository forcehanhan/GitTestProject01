using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>Boundary：游戏视图的边界，也是Player的活动范围。</summary>
[System.Serializable]
public class Boundary
{
    /// <summary> xMin：边界的x轴最小值。</summary>
    public float xMin = -5.9f;

    /// <summary> xMax：边界的x轴最大值。</summary>
    public float xMax = 5.9f;

    /// <summary>zMin：边界的z轴最小值。</summary>
    public float zMin = -4.0f;

    /// <summary>zMax：边界的z轴最大值。</summary>
    public float zMax = 14.0f;

}//Boundary

public class PlayerController : MonoBehaviour
{
    public Boundary boundary;

    /// <summary>移动速度</summary>
    float speed = 10.0f;

    float moveHorizontal;//水平移动
    float moveVertical;//垂直移动

    /// <summary>tilt：飞船左右移动时的倾斜度。</summary>
    float tilt = 5.0f;

    /// <summary>fireRate：子弹发射频率</summary>
    float fireRate = 0.15f;

    /// <summary>nextFire：下一次发射子弹的时间间隔</summary>
    float nextFire;

    /// <summary> movement：接收移动的向量</summary>
    Vector3 movement;

    /// <summary>rb：获取子弹的刚体</summary>
    Rigidbody rb;

    /// <summary> bullet：子弹。</summary>
    public GameObject bullet;

    /// <summary>shotPoint：子弹的射击点。</summary>
    public Transform shotPoint;

    void Start() {
        rb = GetComponent<Rigidbody>();
    }


    void Update() {
        //按下空格键发射子弹,发射子弹的间隔为nextFire
        if (Input.GetKeyDown(KeyCode.Space) && Time.time > nextFire)
        {
            nextFire = Time.time + fireRate;
            Instantiate(bullet, shotPoint.position, transform.rotation);
            //GameObject cloneGameObject = Instantiate(bullet, shotPoint.position, transform.rotation);
            //Destroy(cloneGameObject, 1.5f);
        }
    }
    private void FixedUpdate() {
        moveHorizontal = Input.GetAxis("Horizontal");
        moveVertical = Input.GetAxis("Vertical");

        //接收水平和垂直移动的向量
        movement = new Vector3(moveHorizontal, 0, moveVertical);
        //Debug.Log("h= " + moveHorizontal);
        //Debug.Log("v= " + moveVertical);

        //限定移动边界
        rb.position = new Vector3(Mathf.Clamp(
            rb.position.x, boundary.xMin, boundary.xMax), 0, Mathf.Clamp(rb.position.z, boundary.zMin, boundary.zMax));

        //判断何时移动
        if (rb != null)
        {
            rb.velocity = movement * speed;
            rb.rotation = Quaternion.Euler(0.0f, 0.0f, rb.velocity.x * (-tilt));
        }
    }
}
